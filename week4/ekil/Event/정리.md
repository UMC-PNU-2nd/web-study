## Event

사용자가 마우스로 클릭했을 ‘때’, 스크롤 했을 ‘때’ 등의 **사건**.

브라우저에서 지원하는 이벤트의 종류는 이미 정해져 있음.

[이벤트 참조 | MDN](https://developer.mozilla.org/ko/docs/Web/Events)

### 주요 이벤트 종류

- load: 페이지에 필요한 것(리소스)들이 다 로드됐을 ‘때’(다 로드된 ‘사건’).
- resize: 웹페이지(정확히는 document view)의 크기가 변경됐을 ‘때’
- scroll: 스크롤 됐을 ‘때’
- focus: 요소가 포커스를 받았을 ‘때’ (ex. 마우스로 요소를 클릭한 순간부터)
- blur: 요소가 포커스를 잃었을 ‘때’ (ex. 포커스 상태이던 요소 외의, 다른 부분을 클릭한 찰나의 순간, 포커스 상태였던 요소에는 blur 이벤트가 발생하는 것)
- change: 요소(input 태그, select 태그, textarea 태그)가 포커스를 받고, 사용자에 의해 수정되고, 포커스를 잃었을 ‘때’
- submit: ‘폼’이 제출됐을 ‘때’
- click: 마우스의 버튼이 요소 위에서 눌렸다가 떼어졌을 ‘때’ (mousedown + mouseup)
- mousedown: 마우스의 버튼이 요소 위에서 눌렸을 ‘때’
- mouseup: (눌렸던) 마우스의 버튼이 요소 위에서 떼어졌을 ‘때’
- mouseenter: 마우스 포인터가 요소의 영역 위로 움직여 왔을 ‘때’
- mouseleave: 마우스 포인터가 요소의 영역 밖으로 움직여 나갈 ‘때’
- keydown: 키보드의 키가 눌렸을 ‘때’
- keyup: 키보드의 키 누름(keydown, keypress 이벤트)이 해제될 ‘때’
- (keypress: 키보드의 (Shift, Fn, Caps Lock을 제외한) 키가 쭉 눌리고 있는(눌러지고 있는, 눌림을 당하고 있는) ‘때’)

이런 이벤트가 발생했을 때, JavaScript를 이용해 특정 코드가 실행되게 할 수 있다.

이때 실행될 코드는 **콜백함수**로 나타낼 수 있는데(→ 이벤트에 의해, 이벤트가 발생할 때마다 호출되는 함수이기 때문), 이 함수를 **이벤트핸들러**라고 함.

### 💡 콜백함수

어떤 동작을 완수하기 위한 함수의 인자로 또 다른 함수를 받아야 하는 경우가 있다. 이때 인자로 받아오는 (또 다른) 함수=’콜백함수’

→ 인자로 (콜백)함수를 넘겨받은 뒤, 써야 할 때에 호출(=call back)해 함수가 실행되게 한다.

이벤트핸들러는, 즉시 실행되는 게 아니라 해당 이벤트가 발생했을 때 실행되도록 호출되어야 하므로 콜백함수인 것이다. (즉, 이벤트 발생 전엔 실행 X)

함수를 실행하려는(→ 호출기호 필요) 게 아니라, 이벤트가 발생했을 때 실행할 함수를 알려주려는 것이므로, 함수의 레퍼런스(주소)를 가리키고 있는 ‘함수의 이름’을 적어준다!

### 이벤트핸들러 등록

이벤트 대상(=event target)에 특정한 이벤트가 발생했을 때 이벤트핸들러(콜백함수)가 실행되도록 등록해주어야 함.

(‘container’라는 클래스를 가진 요소가 ‘클릭’될 때(=click 이벤트가 발생할 때)마다 콘솔에 ‘clicked’라고 적어주(는 콜백함수가 실행되)도록 하려면?) → 아래와 같은 세 가지 방식이 있으나, **3번**을 사용하자!

1. HTML에서 인라인으로 등록하기
    
    이벤트 대상인 요소의 태그에, 그 태그의 속성(attribute) 중 하나로 등록
    
    이벤트 종류 앞에 `on`을 써줘야 함
    
    ⭐ HTML(페이지의 뼈대)과 JavaScript(페이지가 동적으로 기능하게 함)의 역할이 다르기에, 분리해서 작성하는 것이 바람직함 → 이 방식은 비추
    
    ```html
    <div class="container" onclick="console.log('clicked');">click me</div>
    ```
    
    ```html
    <div class="container" onclick="handleClick">click me</div>
    
    <script>
    	function handleClick() {
    		console.log('clicked');
    	}
    </script>
    ```
    
2. JavaScript에서 이벤트 대상인 DOM 요소의 속성(property)로 등록하기
    
    `타겟이름.on이벤트종류 = 콜백함수` 형식을 취함
    
    ```jsx
    const $div = document.querySelector('.container');
    
    // 함수 분리해 작성(가독성, 유지보수 편의성)
    $div.onclick = handleClick;
    
    function handleClick() {
    	console.log('clicked');
    }
    
    // 익명 함수로 작성
    $div.onclick = () => console.log('clicked');
    ```
    
    ⭐ 하나의 이벤트 유형(=이벤트의 **대상**도 똑같고, 이벤트의 **종류**도 똑같은 경우)에 여러 개의 이벤트핸들러 적용 **불가** → 이 방식도 비추
    
    ```jsx
    const $div = document.querySelector('.container');
    
    $div.onclick = () => console.log('clicked'); // 이벤트핸들러1
    $div.onclick = () => alert('clicked'); // 이벤트핸들러2
    
    // 제일 마지막에 등록한 것(=이벤트핸들러2)만 실행됨(앞의 것 덮어씀)
    ```
    
3. JavaScript에서 `addEventListener()` 메서드 이용해 등록하기
    
    `타깃이름.addEventListener('이벤트종류', 콜백함수)` 형식
    
    ```jsx
    const $div = document.querySelector('.container');
    
    // 함수 분리해 작성(가독성, 유지보수 편의성) -> functionName 자리에 함수명을 적는다.
    $div.addEventListener('click', handleClick);
    
    function handleClick() {
    	console.log('clicked');
    }
    
    // 익명 함수로 작성 -> functionName 자리에 함수 자체를 적는 것.
    $div.addEventListener('click', () => console.log('clicked'));
    ```
    
    하나의 이벤트 유형(=이벤트의 **대상**도 똑같고, 이벤트의 **종류**도 똑같은 경우)에 여러 개의 이벤트핸들러 적용 가능
    
    ```jsx
    const $div = document.querySelector('.container');
    
    $div.addEventListener('click', () => console.log('clicked')); // 이벤트핸들러1
    $div.addEventListener('click', () => alert('clicked')); // 이벤트핸들러2
    
    // 타깃이 클릭됐을 때, 이벤트핸들러 1, 2 둘 다 실행됨
    // 콘솔 창에 'clicked'가 찍히고, 'clicked'라고 적힌 알림창이 뜸
    ```
    
    💡 Event Flow: ‘useCapture’ → **capture**와 **bubble**
    
    조상-자손 관계를 가진 요소들(ex. `<html>, <body>, <div>`)이 동일한 이벤트 유형(ex. click)에 대한 이벤트핸들러를 각각 가지고 있을 때, 요소들에 이벤트가 전파(=propagation)되는 방식을 정하는 것.
    
    이벤트 전파(=event propagation) 모드(=capture 또는 bubble)에 따라 이벤트를 먼저 수신하는 요소가 달라짐.
    
    자식인 `<div>`와 조상인 `<body>` 둘 다 click 이벤트에 대한 이벤트핸들러를 가지고 있는데 사용자가 `<div>` 영역을 클릭했을 경우, 누구의 이벤트핸들러가 먼저 실행되게 할 것인가.
    
    **capture=부모 → 자식**
    
    **bubble=자식 → 부모**
    
    useCapture의 기본값은 false, 즉 bubble 방식 → 따로 명시하지 않을 경우, bubble이 적용됨
    
    ```jsx
    const $grandParent = document.querySelector('html');
    const $parent = document.querySelector('body');
    const $child = document.querySelector('div');
    
    $grandParent.addEventListener('click', handleClick1, true); // capture
    $parent.addEventListener('click', handleClick2); // bubble
    $child.addEventListener('click', handleClick3);
    
    function handleClick1() {
    	console.log('<html> is clicked');
    }
    
    function handleClick2() {
    	console.log('<body> is clicked');
    }
    
    function handleClick3() {
    	console.log('<div> is clicked');
    }
    
    // Capture phase에서 실행될 이벤트핸들러=handleClick1
    // Bubble phase에서 실행될 이벤트핸들러=handleClick2, 3
    
    // <div> 영역을 클릭하면, 콘솔에 다음과 같이 찍힌다.
    // <html> is clicked
    // <div> is clicked
    // <body> is clicked
    ```
    

### 이벤트핸들러 제거: `removeEventListener()` 메서드 이용

`타깃이름.removeEventListener('이벤트이름', 콜백함수)` 형식

⭐ 익명 함수로 등록한 이벤트핸들러는 이 메서드로 삭제 불가

```jsx
const $div = document.querySelector('.container');

// 이벤트핸들러 등록
$div.addEventListener('click', handleClick);

function handleClick() {
	console.log('clicked');
}

// 등록한 이벤트핸들러 제거
$div.removeEventListener('click', handleClick);
```

### 이벤트 인자

모든 이벤트핸들러의 첫 번재 매개변수=이벤트에 대한 정보를 가지고 있는 인자=이벤트 인자 → e, event 등으로 이름 정해 사용

```jsx
// 콘솔에 이벤트 인자를 찍어보면, 이벤트에 대한 정보들이 담긴 객체가 찍힘

const $div = document.querySelector('.container');

$div.addEventListener('click', handleClick);

function handleClick(event) {
	console.log(event);
}

// PointerEvent { ... }
```

```jsx
// 나열된 정보 객체 중 target 객체=이벤트 타겟에 대한 정보 가지고 있음

const $div = document.querySelector('.container');

$div.addEventListener('click', handleClick);

function handleClick(event) {
	console.log(event.target);
}

// <div class="container">click me</div>
```

```jsx
// target 객체 속 innerHTML 객체

const $div = document.querySelector('.container');

$div.addEventListener('click', handleClick);

function handleClick(event) {
	console.log(event.target.innerHTML);
}

// "click me"
// 태그 속 콘텐츠 그 자체
```

```jsx
// target 객체 속 innerText 객체

const $div = document.querySelector('.container');

$div.addEventListener('click', handleClick);

function handleClick(event) {
	console.log(event.target.innerText);
}

// "CLICK ME"
// CSS로 대문자로 변경해줬던 것이 반영됨
```

이처럼 이벤트에 대한 정보를 뽑아내 이용하고 싶을 때 이벤트 인자를 이용

### `console.dir()` 메서드

`console.log()`: 콘솔에 요소를 **HTML과 같은 트리 구조**로 출력함

`console.dir()`: 콘솔에 요소를 **JSON과 같은 트리 구조**로 출력함
→ 해당 객체의 프로퍼티를 확인할 때 사용!

💡 JSON=JavaScript Object Notation

- 구조화된 데이터를 **JS 객체 문법(key: value 형태)**으로 표현하기 위한 문자 기반의 표준 포맷.
- 웹 어플리케이션에서 "데이터를 전송"할 때 일반적으로 사용.

`<form>`, `<input>` 등 이용해 사용자에게서 값을 받아 어떤 작업을 하려 한다. → 사용자가 입력한 값에 어떻게 접근?

`console.dir()`를 이용 → 출력된 프로퍼티 중, `target` 안의 `value` 프로퍼티의 값이 ‘사용자가 입력한 값’임을 확인

```jsx
const $input = document.querySelector('input');

$input.addEventListener('change', handleChange);

function handleChange(event) {
  console.log(event.target.value);
}

// 사용자가 인풋 창에 입력한 값이 콘솔에 찍힌다!
```

### `preventDefault()` 메서드

인풋 창에 사용자가 값을 입력하고, submit 버튼을 누르거나 Enter를 치면(=submit 이벤트가 발생하면) → 자동으로 form이 제출되고 새로고침됨 = submit 이벤트 기본 성격

이벤트의 기본 성격, 기본적인 동작들을 막아주는 메서드=`preventDefault()`

```jsx
const $form = document.querySelector('form');

$form.addEventListener('submit', handleSubmit);

function handleSubmit(event) {
  event.preventDefault();
}

// submit 이벤트가 발생해도 기본 동작 일어나지 않게 됨
```

submit 이벤트 발생시, 사용자로부터 받은 값을 변수에 저장한 뒤, 정상적인 submit 이벤트처럼 인풋 창이 깔끔하게 비워지게 하려면

```jsx
const $form = document.querySelector('form');
const $input = document.querySelector('input');

$form.addEventListener('submit', handleSubmit);

function handleSubmit(event) {
  event.preventDefault(); // 저장 전에 새로고침 일어나지 않게
	const inputValue = $input.value; // inputValue라는 변수 선언, 거기에 사용자 입력 값을 저장(할당)
	$input.value = ''; // 인풋 창에 입력되어 있는 값을 빈 문자열로 변경 = 새로고침, 초기화나 마찬가지 -> 새로운 입력 값 받을 수 있는 상태가 됨
}

// 사용자가 보기엔 일반적인 submit 이벤트 상황과 똑같은데, 사용자 입력 값을 변수(inputValue)에 저장했음 -> 다른 일을 처리하는 데 이용 가능
```